#All the commits are immutable. That means once the commit is created, they cannot be changed.

#Fetch remote branch upstream/downstram
	git fetch -v

#Creates a new branch
	git checkout -b branch_name - Creates a new branch and switches to it
	git branch branch_name - creates a new branch
	git checkout branch_name - simply switches to given branch

git log # show logs of all the branches
git log --graph --oneline #shows log history in one line
git log branch_name --oneline #You can view logs of any branch while staying on any branch. Just put branch name of the branch you wanna see log off
git status # show the status of the current branch

#Merge branch
1. first check your branch (say dev) which you want to merge with say (master). check if everything alright.
2. then switch to the branch master.
3. check the status of master. check if everything is clean and commited there.
4. now trigger this command to merge. command is git merge dev.
5. Now you can trigger git log cmd to see head will be pointed to master, dev and all the logs will also be shown in the same list.

You can checkout to a new commit with #git checkout commit_id
Then you can check logs of that commit with #git log

git rm --cached <file>..." to unstage files

#Modify previous commit of the branch you're in.
	git checkout branch_name #Move to your desired branch in which you want to make any changes to any particular commit
	git log --graph --oneline #shows log history in one line
	Select your desired commit id
	git checkout <commit_id>
	git commit --amend -m "Modified message"
	git checkout . #Moves the head back to the most current or most recent working directly.


#git hard/soft reset
	If you reset --hard, it will make your local code and local history be just like it was at that commit. But if you wanted to push this to someone else who has the new history, it would fail:
#To undo git soft reset
git checkout <commit-hash>/current-branch-name

	git reset --hard c14809fa
	And if you reset --soft, it will move your HEAD to where they were , but leave your local files etc. the same:

	git reset --soft c14809fa

#To change credentials
git config --global user.email "ctntc9.dpk@gmail.com"
git config --global user.name "Vivid-Vortex"
	
#To sort out long file lenght not supported issue.
git config core.longpaths true #Open git bash/cmd/powershell/termila etc in admin mode

#To change the default editor of git to vim
git config --global core.editor vim

#To change the default editor of git to notepad++
git config --global core.editor notepad++.exe

#To delete the branch
git branch -d branch_name #It will not delete until it is merged, so safe option. Use it always as a first choice over -D option.

#To force delete any branch, even if it's not merged
git branch -D branch_name

#list all the branches
	git branch -a

#To see the history of HEAD movements.
git reflog #press q to move out of the reflog window
----------------------------------------------------------------------------------------
Merge vs Rebase:-
Merge:
	#Say you want to merge main into feature branch.
		git checkout main #move to branch main
		git  pull #pull latest remove branch changes.
		git checkout feature_branch #to the branch (say feature_branch) where you want to merge whatever branch (say main).
		git pull #It will pull the changes from the branch from where it was copied/created in the first place. In this it will pull from local main
		git checkout main
		git merge --no-ff feature_branch #--no-ff option is used to void fast forward merge and previous histories of the feature_branch.
		git push. #Push to remote.

	#Say you just want to update your feature_branch with all the latest changes from main branch.
Rebase:
	git checkout feature_branch
	git rebase main
	#With rebase cmd, git will set aside all the feature_branch changes (commits say commmit1, commit 2) to the holding (temp) area. 
	#After that git will pick every commit from the holding area one by one (first commit1 then commit2 etc.) and then adjust those commits to the latest
	commit on the main branch. Lets' say the latest/recent commit on the main branch is main3. So the commit1 will point to main3 instead of main2. As there were
	#one more commit main3 which was there on the main branch, whcih happens to be the latest and the greatest commit on the main branch. 
	So the chain will look like below.
	Before rebase:
	main1 -> main2 -> main3
						\
						fb1 -> fb2
						
	After rebase:
	main1 -> main2 -> main3
											\
											fb1 -> fb2
	#When you'll move the main branch and merge fb(feature_branch) with -no-ff option. There'll be a third commit main4 (copy of feature branch) which will be created on main branch.
	main1 -> main2 -> main3------main4
											\					/
											fb1 -> fb2
	#But with the help of --no-ff flag/cmd option. You graph/history (i.e.)
	with --no-ff
		main1 -> main2 -> main3------main4
											\					/
											fb1 -> fb2
	
	without --no-ff, incase let's assume there's no other commit history on the main branch and you're only one going to commit to the top of main branch
	in that case there'll be a fast forward commit and the history fb1 -> fb2 will be merged and will no longer exist. So in order to avoid this situation,
	we must use --no-ff option in order to be cautious and preserve history. Becuse you never know if there's or there isn't any commit on the main branch.
	And especially when your intention is to preserve the history (which is always a best practice).
	
	without --no-ff
	
		main1 -> main2 -> main3------main4
		
	#Note:
	#All the commits are immutable. That means once the commit is created, they cannot be changed.
	#This is important to know, because when git rewrites the history of the local branch (feature_branch as per our example), it
	#created a new sha or commit id.
	
	#Important
	#It is important to note that, we should use rebase on local branch only and not the shared branch (github main), because it will rewrite the histories.
	#Also relating to the above point, we should not use rebase on the main branch (which is the local copy of the shared remote branch). We should always
	#checkout to our feature branch and then rebase the local main (of course after pulling the main remote changes to local main) and not the other way round.
	
#Now the question arises, why we should do rebase OF OUR FEATURE_BRANCH in order to pull the latest changes from the main branch (Assuming local main is in sync with remote main).
Say we have a branch like below:

m1 -> m2 -> m3
			\
			f1 -> f2
			
So the situation here is as follows:
After we have taken the copy from point m2 of the main branch and started working further on it. Meanwhile someone else commited their changes to main branch as m3.
Observer carefully this point, in both the cases merge from main to feature_branch wil occur.
While both git pull and git rebase can integrate changes from a main branch into your feature branch, they achieve this in different ways, leading to distinct outcomes and impacting your Git history:

While both git pull and git rebase can integrate changes from a main branch into your feature branch, they achieve this in different ways, leading to distinct outcomes and impacting your Git history:

Git Pull:
Integration: Performs a "merge," creating a new merge commit in your feature branch. This commit records the merging of changes from the main branch at a specific point in time.
Git history: Creates a linear history with branches diverging and then merging. This can make it clearer to visualize how changes integrated from the main branch.
Collaboration: More suitable for working on shared branches where others might be contributing and you want to keep your branch independent. Merge commits track individual contributions.
Potential conflicts: Might require resolving merge conflicts if changes in both branches overlap.

Git Rebase:
Integration: Replays your feature branch commits on top of the latest main branch changes. This rewrites your branch's history to appear as if they were always made after the main branch updates.
Git history: Creates a more streamlined, linear history where your feature branch commits appear directly after the main branch changes. This can be cleaner for personal branches not yet shared.
Collaboration: Less suitable for shared branches as rewriting history can cause issues for others who have already pulled or integrated your branch.
No conflicts: Usually doesn't introduce merge conflicts, as your commits are replayed on top of the main branch without merging.

Choosing the right option:
Pull: Use if you're working on a shared branch, want separate merge commits for tracking changes, and are willing to handle potential conflicts.
Rebase: Use if you're working on a personal branch, prefer a cleaner history, and don't anticipate collaborating with others on the branch.

-------My Two Cents on using Merge and Rebase----------
1. We must not use rebase outside the unshred feature local branch at all.
2. We should always prefer merge over rebase, in order to merge the branches, as both will ultimately do merge only and create a merge commit.
3. We should use only interactive rebase as there are multiple useful options availabel under it. And if we have to use those options then only we should hink of rebasing.
-----------------------------

Remember:
Be cautious with rebasing shared branches due to potential disruptions for others.
Consider using git pull --rebase to rebase after pulling changes (only recommended for advanced users).
Understand the implications of each approach before integrating changes.

Conclusion:
1. First rebase your feature_branch to main branch (and keep on rebasing your feature_branch from time to time until you finish working on that feature branch) and then merging
to main, instead of directly pulling and merging to main. Chances of conflicts would be too high otherwise.
2. Always (extremely important to note), do the rebase on your local non-shared branch (in this case it is feature_branch)
----------------------------------------------------------------------------------------
Differenc between Merge and pull. The point is that in both the cases content is flowing from one point to another, so what's the difference.
Point is we can checkout main and pull the changes from feature_branch to main. And then push it to remote. And likewise every team member can do.
Same thing we can checkout feature_branch and pull the changes from main. So What's difference.

And. The difference lies in the history. When we merge any changes from any branch to any branch, there will be a "merge commit" created corresponding to that.
We already know merging from any feature_branch to main and the merge commit gets created. Same way we can merge main into any feature_branch and likewise a merge commitw
will be created. So instead of pullling main branch changes we are merging main to the feature_branch. That will create a merge commit on the feature brancha
and this commit will be shown on the branch as the commit (both visually and as commmit sha).

m1 -> m2 -> m3----
			\						\		
			f1 -> f2 -> m4

In the above pic, m4 which is the merge commit on feature_branch has all the changes as well as the merge commit history on the feature_branch itself.

----------------------------------------------------------------------------------------
Resolving merge and/or rebase conflits:
git merge --abort #It will abort any merge in case of any conflicts
Check this image:
ResolvingConflicts.jpg

-----------
If you want to abort the merge/rebase then use git merge/rebase --abort. It will put the current directory back to normal state.
If you want to contiue with the ongoing merge/rebase operation, then go to that file (which would be showing along with the conflict message) and fix the conflict.
then run git add . #It will mark the conflict as resolved.
then run git merge/rebase --continue
merge/rebase is done now.
You can check the log graph with git log --graph --oneline
-----------

----------------------------------------------------------------------------------------
git cherry pick and resolving cherry pick conflict:

----------------------------------------------------------------------------------------
Rewriting Git History:
	Amending commits
	Rewording commit messages
	Deleting commits
	Reordering commits
	Squashing commits
	Splitting commits

Quick tips: Just use git rebase -i HEAD~number_of_commits_from_head_you_wanna_go_back
example:- git rebase -i HEAD~2
An editor will be opened after hitting enter. Just replace the commands the sha. Commands would be given under commented Commands: section.
After hitting enter, another editor will open, where you can do your work. Save and exit.
----------------------------------------------------------------------------------------
Stashing:
Very simple stash workflow:
	git stash #It will stash all the tracked files (but not the untracked ones, so first do git add . to stage all the current files before stashing)
	git stash list #It will show the list of all the stash entries.
	git statsh show #If only one stash entry
	git stash pop #It will take the latest stash from the stash stack

git stash -m "stash_comment" #It will allow to give some meaningful comment to the stash to easily identify it laster
git stash list #It will show the stash stack with that comment you addede in the last step.

git stash pop --index stash_index_numer #stash_index_numer will be the number of fetch a particular index with its number

#You can assign a particular stash to their own branch only
git stash branch branch_name index_number #With this cmd, you can assign the statsh with index number say 1 (you've given in index_number to) to it's own branch with branch name given. And after runnig this cmd, you will automatically be moved to that branch.
git log --oneline #You will find out that you're now in the new brancha

#To drop a stash entry
git stash drop index_number

#To drop entire stash stack
git stash clear

##fixing merge conflict

#In case of any conflit which arises during stash pop operation. If you have any unstaged changes in your working directory then 
#git will abort the stash pop operation and the put the popped stash back to the stack.
#Plus it will also let us know what's the problem is.

git status #It will show the modified files in your working directory
git stash show index_number #The index should be of the stash number for which you got the conflict. You will see both the cmds (above and this one) will point to the same file.

#Strategy 1 to fix the conflict. Simply put of the changes (working directory changes or stash changes) to another seperate branch. And when you're done with your current change. You can either merge or rebase these two branches.

#Strategy 2 is to know that the stash operation is being aborted since we had some unstaged files in our working directory. 
#So first thing to do is to stage the changes in our working directoy (Only staging will do and commit not necessary).
#Now do pop
git stash pop index_number
#You will get conflict. But now you will clearly see the files where conflict is in red and the files which can be merge without any issue in green.
#So open that file in red and manually fix the issue and then save it
#git status
#You will see the changes which are staged in green and just now merged fixed file in red saying unmerged paths. So to resolve this finally use git add . cmd and it will resolve the conflict.
git status #Now everything should be staged and in green
#Merg conflict resolved!!!
#Go one step further
#As a best practice, leave a trail of this issue for the future developer or may be you in future to know that you got this issue in the past
#So to leave a trail, create a commit history or simply say commit with a proper message.
#git log --oneline
#So if you remember we solved the stash merge conflict manually. So we need to clear the stash manually (becuase there was a  conflict, git will not remove the itself).
git stash list
git stash drop index_number
git stash list

----------------------------------------------------------------------------------------
#Git Delete

git log --oneline
git reset --hard HEAD~1 #HEAD will move one step back and since it is a hard reset, anything above head will be gone (DELETED). That included commits and working directory changes. So be very careful.

#So now insted of deleting anything, you can choose to undo the commit only. 
#This is different from deleting, since changes are only uncommited and will move back to the staging area. And so it will not be deleted from the working directory either.
git reset --soft HEAD~1 #It will undo you last commit and will move back the changes to the "staging area" (and not the working directory) or commited changes to uncommited state
but it won't affect your working directory.
git log --online #The last commit will not show in the graph
git status #You wil find your last commited changes back in the staging area.

#Deleting commits further than one commit from the HEAD.

A word of caution: Never drop commits on the shared branch. Or as a rule of thumb, never do it outside feature branch or non-shared branch (which you're not going to push to remote stream.)
And if for any reason if you have to push the droped commit to the shared branch use git reword which is like reversing the effects of a commit non distructively.
Git reword is also a safer alternative to git drop, but it's non destructive in nature.
git rebase -i HEAD~2 #I want to "manipulate" last two commits from HEAD. Using the term manipulate because we can do alot of operations using interactive reabse. rebase -i means Interactive rebase. 
A pop up will open an editor after this cmd.
In the opened editor you'll see two last two commits (because we did HEAD~2) in one graph line way
Now from here just change the initial letter of the commit which you want to play with. Say if pick some_hash Updated READMe is shown, then simply make the pick to drop in order to drop that particular commit.
And when you will save and close the editor, git will start doing rebasing. So essentially git will start from that first commit which appeard in the pop up window after rebase -i cmd, and then it will move back towards initial position of the HEAD.
One thing to note here is that, since git commits are immutable in nature. So essentially when we are doing rebase, git is changing the history or rewritting the history.
So essentially, when we saved the editor after rebase -i cmd, git will start moving from that first commit that appeard in that interactive rebase editor and it till start moving towards,
the previous HEAD position. In the process, it will definetly rewrite or do whatever cmds we chosse in the interactive rebase windws and in addition to that it will also
replace all the other commits with a new commit hash. Essentially it means all the changes of those unmodified commits will remain same, but it will be put in place with a new hash.

fb1 -> fb2 -> fb3

Higher chance of conflict when doing git drop in interactive rebase especiallly when doing the drop operation way below the latest commit. Becuase there will be multiple transitive dependencies which will produce conflict.
So essentially, let's say if we try to drop fb3, then a conflict might occurs becuae some files in fb3 commit, which would be dependent on fb2 which we are not deleting.
So this way git drop has a higher chanches of conflict. So better to avoid it. And better we should not choose to drop any commit at the first  place. So whatever operations we
have to do, we should do it in current working directly state and then commit it with a proper commit message and a obviosuely a new commit id/hash. And most importantly,
since as a thumb rule we must do these kind of operation in a seperate branch, as a best practice as we know, we should use atomic commit and don't make the feature branch
very large and then wait for it to merge in the main branch. If we use atomic commits, then there will be no such deep commits which you will have to drop, so the situation will not arise in the first place.

so If any conflict already occured. so runnig
git rebase --abort #to abort the rebasing in case of conflict.

#git revert
So better use another alternative which is git revert which is also non destructive.

----------------------------------------------------------------------------------------
Change commit message:

#To modify the latest commit message
git commit --amend -m "New commit message"

#To modify any commit below the latest commit
#Use interactive rebase
git rebase -i HEAD~2 #It will show the last two commit in the editor of you choise.
#You will see two commits with pick in the begening followd by the sha and then the commit message.
#pick means no-op (No operation) for git
#Change the pick for the commit for which you want to reword the commit message.
#Changing the reword will give you an opportunity by git (when it will run reabse after you save and close the editor) to type a commit message of your choice.
#All the hash shown in that opened editor will be modified since git commits are immutable. It will generate another copy of those and discard the old one, through garbage collector, whch you can run by yoru own using git gc if you want to, or else it will run automatically.

----------------------------------------------------------------------------------------
git squash:
#squash is not a command. It is one of the many options available under git interactive rebasing system.
#Squash is used to repackage commits which are related to each other.
git rebase -i HEAD~3 #It will tell the git that I want to act upon the last 3 commits.
So as always we do in rebase interactive, we just need to touch the keyword pick for the commits which we want to modify in anyway.
Ans since we are going to squash (or meld in other words) particularly so in this case pick will be modified to sqash (also you can see the same under the comments section of the opend file.)
So just change the picks of the commits which you want to squash in one commit.
So as always in interactive rebase, once you save and close the first editor, another editor will open which will allow you to do your changes.
Now in the second editor, just edit comment (as you would usually prefer over delete unless everythigs okay. Aslo better than remove) or remove those commit messages.

----------------------------------------------------------------------------------------
Staging is a part of the repository's state, not tied to a specific branch:
Use case:
Initially I had only one branch master in git. In this branch I added a text file name dev1.txt. Then without staging it, I 
checkedout and created and branch name dev1 from this branch master. After checking out to dev1, I staged dev1.txt. When I 
did git checkout master again, why is dev1.txt staged there, even through I had staged this file only in dev1 and not in master.

Reason:
When you switch between branches in Git, any changes that are not committed are carried over to the new branch. This includes staged changes.

In your scenario, you initially made changes to the master branch by adding a text file named dev1.txt. Then, without staging this file, you created a new branch called dev1 from master. 
When you switched to the dev1 branch and staged dev1.txt, you staged the changes in that branch only.

However, when you checked out master again, Git kept the staged changes (in this case, the staging of dev1.txt) because staging is a part of the repository's state, not tied to a specific branch. Git doesn't reset the staging area when you switch branches; 
it preserves the staging area to maintain the changes you've made until you either commit or reset them explicitly.

If you want to unstage changes when switching branches, you can use the command:

git reset

This will unstage any changes in the current branch, allowing you to switch to another branch without carrying over the staged changes.

				{Staging area}
{master}							{dev1}

As you can see in the above pic that staging area is common to both master and dev1 branch.
--------------
#When you create any branch from any branch (say dev1 from master), so the "commited" changes (commited only and not the staged only changes because 
staging is part of the overrall git repo and not tied to any branch) will be carry foraded to the next branch you're creating, because it was created considering
it as a base for the next branch. So all the committed changes from master will be copied to dev1.

#When you create a branch without commiting anything in the current branch. So nothing will be carry forwaded. The changes will remain intact to the branch
where you will first commit the staged files. Just imagine this in the below picture.

				{Staging area}
{master}							{dev1}
--------------
#If no changes are there between the current branch you're in and the new branch you're creating, then the new branch will not be spawned from the branch you're in currently.
#In that case, since both the branches (i.e. the current branch you're in and the newly created branch) will point to the next content/commit matching branch.

Below pic depicts when both dev1 and dev2 commits/changes are same as main
main----
	\		\
	dev1 \
			dev2

Below pic depicts when we create another branch dev2, when the base branch content is different from it's base branch, that is main. So it create a new branch spawning from dev1.
main----
	\		
	dev1 
		\
		dev2
----------------------------------------------------------------------------------------











