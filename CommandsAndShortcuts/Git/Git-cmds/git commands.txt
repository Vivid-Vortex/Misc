#All the commits are immutable. That means once the commit is created, they cannot be changed.

#Fetch remote branch upstream/downstram
	git fetch -v

#Creates a new branch
	git checkout -b branch_name - Creates a new branch and switches to it
	git branch branch_name - creates a new branch
	git checkout branch_name - simply switches to given branch

#list all the branches
	git branch -a

git log # show logs of all the branches
git log --graph --oneline #shows log history in one line
git status # show the status of the current branch

#Merge branch
1. first check your branch (say dev) which you want to merge with say (master). check if everything alright.
2. then switch to the branch master.
3. check the status of master. check if everything is clean and commited there.
4. now trigger this command to merge. command is git merge dev.
5. Now you can trigger git log cmd to see head will be pointed to master, dev and all the logs will also be shown in the same list.

You can checkout to a new commit with #git checkout commit_id
Then you can check logs of that commit with #git log

git rm --cached <file>..." to unstage files

#Modify previous commit of the branch you're in.
	git checkout branch_name #Move to your desired branch in which you want to make any changes to any particular commit
	git log --graph --oneline #shows log history in one line
	Select your desired commit id
	git checkout <commit_id>
	git commit --amend -m "Modified message"
	git checkout . #Moves the head back to the most current or most recent working directly.


#git hard/soft reset
	If you reset --hard, it will make your local code and local history be just like it was at that commit. But if you wanted to push this to someone else who has the new history, it would fail:

	git reset --hard c14809fa
	And if you reset --soft, it will move your HEAD to where they were , but leave your local files etc. the same:

	git reset --soft c14809fa

#To sort out long file lenght not supported issue.
git config core.longpaths true #Open git bash/cmd/powershell/termila etc in admin mode
----------------------------------------------------------------------------------------
Merge vs Rebase:-
Merge:
	#Say you want to merge main into feature branch.
		git checkout main #move to branch main
		git  pull #pull latest remove branch changes.
		git checkout feature_branch #to the branch (say feature_branch) where you want to merge whatever branch (say main).
		git pull #It will pull the changes from the branch from where it was copied/created in the first place. In this it will pull from local main
		git checkout main
		git merge --no-ff feature_branch #--no-ff option is used to void fast forward merge and previous histories of the feature_branch.
		git push. #Push to remote.

	#Say you just want to update your feature_branch with all the latest changes from main branch.
Rebase:
	git checkout feature_branch
	git rebase main
	#With rebase cmd, git will set aside all the feature_branch changes (commits say commmit1, commit 2) to the holding (temp) area. 
	#After that git will pick every commit from the holding area one by one (first commit1 then commit2 etc.) and then adjust those commits to the latest
	commit on the main branch. Lets' say the latest/recent commit on the main branch is main3. So the commit1 will point to main3 instead of main2. As there were
	#one more commit main3 which was there on the main branch, whcih happens to be the latest and the greatest commit on the main branch. 
	So the chain will look like below.
	Before rebase:
	main1 -> main2 -> main3
						\
						fb1 -> fb2
						
	After rebase:
	main1 -> main2 -> main3
											\
											fb1 -> fb2
	#When you'll move the main branch and merge fb(feature_branch) with -no-ff option. There'll be a third commit main4 (copy of feature branch) which will be created on main branch.
	main1 -> main2 -> main3------main4
											\					/
											fb1 -> fb2
	#But with the help of --no-ff flag/cmd option. You graph/history (i.e.)
	with --no-ff
		main1 -> main2 -> main3------main4
											\					/
											fb1 -> fb2
	
	without --no-ff, incase let's assume there's no other commit history on the main branch and you're only one going to commit to the top of main branch
	in that case there'll be a fast forward commit and the history fb1 -> fb2 will be merged and will no longer exist. So in order to avoid this situation,
	we must use --no-ff option in order to be cautious and preserve history. Becuse you never know if there's or there isn't any commit on the main branch.
	And especially when your intention is to preserve the history (which is always a best practice).
	
	without --no-ff
	
		main1 -> main2 -> main3------main4
		
	#Note:
	#All the commits are immutable. That means once the commit is created, they cannot be changed.
	#This is important to know, because when git rewrites the history of the local branch (feature_branch as per our example), it
	#created a new sha or commit id.
	
	#Important
	#It is important to note that, we should use rebase on local branch only and not the shared branch (github main), because it will rewrite the histories.
	#Also relating to the above point, we should not use rebase on the main branch (which is the local copy of the shared remote branch). We should always
	#checkout to our feature branch and then rebase the local main (of course after pulling the main remote changes to local main) and not the other way round.
	
#Now the question arises, why we should do rebase OF OUR FEATURE_BRANCH in order to pull the latest changes from the main branch (Assuming local main is in sync with remote main).
Say we have a branch like below:

m1 -> m2 -> m3
			\
			f1 -> f2
			
So the situation here is as follows:
After we have taken the copy from point m2 of the main branch and started working further on it. Meanwhile someone else commited their changes to main branch as m3.
Observer carefully this point, in both the cases merge from main to feature_branch wil occur.
While both git pull and git rebase can integrate changes from a main branch into your feature branch, they achieve this in different ways, leading to distinct outcomes and impacting your Git history:

While both git pull and git rebase can integrate changes from a main branch into your feature branch, they achieve this in different ways, leading to distinct outcomes and impacting your Git history:

Git Pull:
Integration: Performs a "merge," creating a new merge commit in your feature branch. This commit records the merging of changes from the main branch at a specific point in time.
Git history: Creates a linear history with branches diverging and then merging. This can make it clearer to visualize how changes integrated from the main branch.
Collaboration: More suitable for working on shared branches where others might be contributing and you want to keep your branch independent. Merge commits track individual contributions.
Potential conflicts: Might require resolving merge conflicts if changes in both branches overlap.

Git Rebase:
Integration: Replays your feature branch commits on top of the latest main branch changes. This rewrites your branch's history to appear as if they were always made after the main branch updates.
Git history: Creates a more streamlined, linear history where your feature branch commits appear directly after the main branch changes. This can be cleaner for personal branches not yet shared.
Collaboration: Less suitable for shared branches as rewriting history can cause issues for others who have already pulled or integrated your branch.
No conflicts: Usually doesn't introduce merge conflicts, as your commits are replayed on top of the main branch without merging.

Choosing the right option:
Pull: Use if you're working on a shared branch, want separate merge commits for tracking changes, and are willing to handle potential conflicts.
Rebase: Use if you're working on a personal branch, prefer a cleaner history, and don't anticipate collaborating with others on the branch.

Remember:
Be cautious with rebasing shared branches due to potential disruptions for others.
Consider using git pull --rebase to rebase after pulling changes (only recommended for advanced users).
Understand the implications of each approach before integrating changes.

Conclusion:
1. First rebase your feature_branch to main branch (and keep on rebasing your feature_branch from time to time until you finish working on that feature branch) and then merging
to main, instead of directly pulling and merging to main. Chances of conflicts would be too high otherwise.
2. Always (extremely important to note), do the rebase on your local non-shared branch (in this case it is feature_branch)
----------------------------------------------------------------------------------------
Differenc between Merge and pull. The point is that in both the cases content is flowing from one point to another, so what's the difference.
Point is we can checkout main and pull the changes from feature_branch to main. And then push it to remote. And likewise every team member can do.
Same thing we can checkout feature_branch and pull the changes from main. So What's difference.

And. The difference lies in the history. When we merge any changes from any branch to any branch, there will be a "merge commit" created corresponding to that.
We already know merging from any feature_branch to main and the merge commit gets created. Same way we can merge main into any feature_branch and likewise a merge commitw
will be created. So instead of pullling main branch changes we are merging main to the feature_branch. That will create a merge commit on the feature brancha
and this commit will be shown on the branch as the commit (both visually and as commmit sha).

m1 -> m2 -> m3----
			\						\		
			f1 -> f2 -> m4

In the above pic, m4 which is the merge commit on feature_branch has all the changes as well as the merge commit history on the feature_branch itself.

----------------------------------------------------------------------------------------
Resolving conflits:
git merge --abort #It will abort any merge in case of any conflicts
Check this image:
ResolvingConflicts.jpg
----------------------------------------------------------------------------------------